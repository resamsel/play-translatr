"use strict";
/**
 * The Translatr API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
exports.__esModule = true;
var localVarRequest = require("request");
var Promise = require("bluebird");
var defaultBasePath = 'https://localhost:9000/api';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
var primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
var ObjectSerializer = /** @class */ (function () {
    function ObjectSerializer() {
    }
    ObjectSerializer.findCorrectType = function (data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            var discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    };
    ObjectSerializer.serialize = function (data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            var subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            var transformedData = [];
            for (var index in data) {
                var date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            var attributeTypes = typeMap[type].getAttributeTypeMap();
            var instance = {};
            for (var index in attributeTypes) {
                var attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    };
    ObjectSerializer.deserialize = function (data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            var subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            var transformedData = [];
            for (var index in data) {
                var date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            var instance = new typeMap[type]();
            var attributeTypes = typeMap[type].getAttributeTypeMap();
            for (var index in attributeTypes) {
                var attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    };
    return ObjectSerializer;
}());
var ActivitiesPaged = /** @class */ (function () {
    function ActivitiesPaged() {
    }
    ActivitiesPaged.getAttributeTypeMap = function () {
        return ActivitiesPaged.attributeTypeMap;
    };
    ActivitiesPaged.discriminator = undefined;
    ActivitiesPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<Activity>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return ActivitiesPaged;
}());
exports.ActivitiesPaged = ActivitiesPaged;
var Activity = /** @class */ (function () {
    function Activity() {
    }
    Activity.getAttributeTypeMap = function () {
        return Activity.attributeTypeMap;
    };
    Activity.discriminator = undefined;
    Activity.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Activity.TypeEnum"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "userUsername",
            "baseName": "userUsername",
            "type": "string"
        },
        {
            "name": "userEmail",
            "baseName": "userEmail",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "before",
            "baseName": "before",
            "type": "string"
        },
        {
            "name": "after",
            "baseName": "after",
            "type": "string"
        }
    ];
    return Activity;
}());
exports.Activity = Activity;
(function (Activity) {
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Create"] = 'Create'] = "Create";
        TypeEnum[TypeEnum["Update"] = 'Update'] = "Update";
        TypeEnum[TypeEnum["Delete"] = 'Delete'] = "Delete";
        TypeEnum[TypeEnum["Login"] = 'Login'] = "Login";
        TypeEnum[TypeEnum["Logout"] = 'Logout'] = "Logout";
    })(TypeEnum = Activity.TypeEnum || (Activity.TypeEnum = {}));
})(Activity = exports.Activity || (exports.Activity = {}));
exports.Activity = Activity;
var Aggregate = /** @class */ (function () {
    function Aggregate() {
    }
    Aggregate.getAttributeTypeMap = function () {
        return Aggregate.attributeTypeMap;
    };
    Aggregate.discriminator = undefined;
    Aggregate.attributeTypeMap = [
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "millis",
            "baseName": "millis",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }
    ];
    return Aggregate;
}());
exports.Aggregate = Aggregate;
var AggregatedNotification = /** @class */ (function () {
    function AggregatedNotification() {
    }
    AggregatedNotification.getAttributeTypeMap = function () {
        return AggregatedNotification.attributeTypeMap;
    };
    AggregatedNotification.discriminator = undefined;
    AggregatedNotification.attributeTypeMap = [
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "whenUpdated",
            "baseName": "whenUpdated",
            "type": "Date"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "subtitle",
            "baseName": "subtitle",
            "type": "string"
        },
        {
            "name": "verb",
            "baseName": "verb",
            "type": "string"
        },
        {
            "name": "activityCount",
            "baseName": "activityCount",
            "type": "number"
        },
        {
            "name": "actorCount",
            "baseName": "actorCount",
            "type": "number"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "project",
            "baseName": "project",
            "type": "Project"
        }
    ];
    return AggregatedNotification;
}());
exports.AggregatedNotification = AggregatedNotification;
var AggregatesPaged = /** @class */ (function () {
    function AggregatesPaged() {
    }
    AggregatesPaged.getAttributeTypeMap = function () {
        return AggregatesPaged.attributeTypeMap;
    };
    AggregatesPaged.discriminator = undefined;
    AggregatesPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<Aggregate>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return AggregatesPaged;
}());
exports.AggregatesPaged = AggregatesPaged;
var CompletionStageResult = /** @class */ (function () {
    function CompletionStageResult() {
    }
    CompletionStageResult.getAttributeTypeMap = function () {
        return CompletionStageResult.attributeTypeMap;
    };
    CompletionStageResult.discriminator = undefined;
    CompletionStageResult.attributeTypeMap = [];
    return CompletionStageResult;
}());
exports.CompletionStageResult = CompletionStageResult;
var ConstraintViolation = /** @class */ (function () {
    function ConstraintViolation() {
    }
    ConstraintViolation.getAttributeTypeMap = function () {
        return ConstraintViolation.attributeTypeMap;
    };
    ConstraintViolation.discriminator = undefined;
    ConstraintViolation.attributeTypeMap = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "invalidValue",
            "baseName": "invalidValue",
            "type": "number"
        }
    ];
    return ConstraintViolation;
}());
exports.ConstraintViolation = ConstraintViolation;
var ConstraintViolationError = /** @class */ (function () {
    function ConstraintViolationError() {
    }
    ConstraintViolationError.getAttributeTypeMap = function () {
        return ConstraintViolationError.attributeTypeMap;
    };
    ConstraintViolationError.discriminator = undefined;
    ConstraintViolationError.attributeTypeMap = [
        {
            "name": "error",
            "baseName": "error",
            "type": "ConstraintViolationErrorInfo"
        }
    ];
    return ConstraintViolationError;
}());
exports.ConstraintViolationError = ConstraintViolationError;
var ConstraintViolationErrorInfo = /** @class */ (function () {
    function ConstraintViolationErrorInfo() {
    }
    ConstraintViolationErrorInfo.getAttributeTypeMap = function () {
        return ConstraintViolationErrorInfo.attributeTypeMap;
    };
    ConstraintViolationErrorInfo.discriminator = undefined;
    ConstraintViolationErrorInfo.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "violations",
            "baseName": "violations",
            "type": "Array<ConstraintViolation>"
        }
    ];
    return ConstraintViolationErrorInfo;
}());
exports.ConstraintViolationErrorInfo = ConstraintViolationErrorInfo;
var Data = /** @class */ (function () {
    function Data() {
    }
    Data.getAttributeTypeMap = function () {
        return Data.attributeTypeMap;
    };
    Data.discriminator = undefined;
    Data.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }
    ];
    return Data;
}());
exports.Data = Data;
var FutureInteger = /** @class */ (function () {
    function FutureInteger() {
    }
    FutureInteger.getAttributeTypeMap = function () {
        return FutureInteger.attributeTypeMap;
    };
    FutureInteger.discriminator = undefined;
    FutureInteger.attributeTypeMap = [
        {
            "name": "cancelled",
            "baseName": "cancelled",
            "type": "boolean"
        },
        {
            "name": "done",
            "baseName": "done",
            "type": "boolean"
        }
    ];
    return FutureInteger;
}());
exports.FutureInteger = FutureInteger;
var GenericError = /** @class */ (function () {
    function GenericError() {
    }
    GenericError.getAttributeTypeMap = function () {
        return GenericError.attributeTypeMap;
    };
    GenericError.discriminator = undefined;
    GenericError.attributeTypeMap = [
        {
            "name": "error",
            "baseName": "error",
            "type": "GenericErrorInfo"
        }
    ];
    return GenericError;
}());
exports.GenericError = GenericError;
var GenericErrorInfo = /** @class */ (function () {
    function GenericErrorInfo() {
    }
    GenericErrorInfo.getAttributeTypeMap = function () {
        return GenericErrorInfo.attributeTypeMap;
    };
    GenericErrorInfo.discriminator = undefined;
    GenericErrorInfo.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }
    ];
    return GenericErrorInfo;
}());
exports.GenericErrorInfo = GenericErrorInfo;
var Key = /** @class */ (function () {
    function Key() {
    }
    Key.getAttributeTypeMap = function () {
        return Key.attributeTypeMap;
    };
    Key.discriminator = undefined;
    Key.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "whenUpdated",
            "baseName": "whenUpdated",
            "type": "Date"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "projectOwnerUsername",
            "baseName": "projectOwnerUsername",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pathName",
            "baseName": "pathName",
            "type": "string"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "{ [key: string]: Message; }"
        }
    ];
    return Key;
}());
exports.Key = Key;
var KeysPaged = /** @class */ (function () {
    function KeysPaged() {
    }
    KeysPaged.getAttributeTypeMap = function () {
        return KeysPaged.attributeTypeMap;
    };
    KeysPaged.discriminator = undefined;
    KeysPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<Key>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return KeysPaged;
}());
exports.KeysPaged = KeysPaged;
var Locale = /** @class */ (function () {
    function Locale() {
    }
    Locale.getAttributeTypeMap = function () {
        return Locale.attributeTypeMap;
    };
    Locale.discriminator = undefined;
    Locale.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "whenUpdated",
            "baseName": "whenUpdated",
            "type": "Date"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "projectOwnerUsername",
            "baseName": "projectOwnerUsername",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "pathName",
            "baseName": "pathName",
            "type": "string"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "{ [key: string]: Message; }"
        }
    ];
    return Locale;
}());
exports.Locale = Locale;
var LocalesPaged = /** @class */ (function () {
    function LocalesPaged() {
    }
    LocalesPaged.getAttributeTypeMap = function () {
        return LocalesPaged.attributeTypeMap;
    };
    LocalesPaged.discriminator = undefined;
    LocalesPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<Locale>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return LocalesPaged;
}());
exports.LocalesPaged = LocalesPaged;
var Message = /** @class */ (function () {
    function Message() {
    }
    Message.getAttributeTypeMap = function () {
        return Message.attributeTypeMap;
    };
    Message.discriminator = undefined;
    Message.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "localeId",
            "baseName": "localeId",
            "type": "string"
        },
        {
            "name": "localeName",
            "baseName": "localeName",
            "type": "string"
        },
        {
            "name": "localePathName",
            "baseName": "localePathName",
            "type": "string"
        },
        {
            "name": "keyId",
            "baseName": "keyId",
            "type": "string"
        },
        {
            "name": "keyName",
            "baseName": "keyName",
            "type": "string"
        },
        {
            "name": "keyPathName",
            "baseName": "keyPathName",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "projectOwnerUsername",
            "baseName": "projectOwnerUsername",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }
    ];
    return Message;
}());
exports.Message = Message;
var MessagesPaged = /** @class */ (function () {
    function MessagesPaged() {
    }
    MessagesPaged.getAttributeTypeMap = function () {
        return MessagesPaged.attributeTypeMap;
    };
    MessagesPaged.discriminator = undefined;
    MessagesPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<Message>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return MessagesPaged;
}());
exports.MessagesPaged = MessagesPaged;
var NotFoundError = /** @class */ (function () {
    function NotFoundError() {
    }
    NotFoundError.getAttributeTypeMap = function () {
        return NotFoundError.attributeTypeMap;
    };
    NotFoundError.discriminator = undefined;
    NotFoundError.attributeTypeMap = [
        {
            "name": "error",
            "baseName": "error",
            "type": "NotFoundErrorInfo"
        }
    ];
    return NotFoundError;
}());
exports.NotFoundError = NotFoundError;
var NotFoundErrorInfo = /** @class */ (function () {
    function NotFoundErrorInfo() {
    }
    NotFoundErrorInfo.getAttributeTypeMap = function () {
        return NotFoundErrorInfo.attributeTypeMap;
    };
    NotFoundErrorInfo.discriminator = undefined;
    NotFoundErrorInfo.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "entity",
            "baseName": "entity",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }
    ];
    return NotFoundErrorInfo;
}());
exports.NotFoundErrorInfo = NotFoundErrorInfo;
var NotificationsPaged = /** @class */ (function () {
    function NotificationsPaged() {
    }
    NotificationsPaged.getAttributeTypeMap = function () {
        return NotificationsPaged.attributeTypeMap;
    };
    NotificationsPaged.discriminator = undefined;
    NotificationsPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<AggregatedNotification>"
        },
        {
            "name": "totalRowCount",
            "baseName": "totalRowCount",
            "type": "number"
        },
        {
            "name": "futureCount",
            "baseName": "futureCount",
            "type": "FutureInteger"
        },
        {
            "name": "totalPageCount",
            "baseName": "totalPageCount",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "pageSize",
            "type": "number"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "futureRowCount",
            "baseName": "futureRowCount",
            "type": "FutureInteger"
        }
    ];
    return NotificationsPaged;
}());
exports.NotificationsPaged = NotificationsPaged;
var PermissionError = /** @class */ (function () {
    function PermissionError() {
    }
    PermissionError.getAttributeTypeMap = function () {
        return PermissionError.attributeTypeMap;
    };
    PermissionError.discriminator = undefined;
    PermissionError.attributeTypeMap = [
        {
            "name": "error",
            "baseName": "error",
            "type": "PermissionErrorInfo"
        }
    ];
    return PermissionError;
}());
exports.PermissionError = PermissionError;
var PermissionErrorInfo = /** @class */ (function () {
    function PermissionErrorInfo() {
    }
    PermissionErrorInfo.getAttributeTypeMap = function () {
        return PermissionErrorInfo.attributeTypeMap;
    };
    PermissionErrorInfo.discriminator = undefined;
    PermissionErrorInfo.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "scopes",
            "baseName": "scopes",
            "type": "Array<PermissionErrorInfo.ScopesEnum>"
        }
    ];
    return PermissionErrorInfo;
}());
exports.PermissionErrorInfo = PermissionErrorInfo;
(function (PermissionErrorInfo) {
    var ScopesEnum;
    (function (ScopesEnum) {
        ScopesEnum[ScopesEnum["UserRead"] = 'UserRead'] = "UserRead";
        ScopesEnum[ScopesEnum["UserWrite"] = 'UserWrite'] = "UserWrite";
        ScopesEnum[ScopesEnum["ProjectRead"] = 'ProjectRead'] = "ProjectRead";
        ScopesEnum[ScopesEnum["ProjectWrite"] = 'ProjectWrite'] = "ProjectWrite";
        ScopesEnum[ScopesEnum["LocaleRead"] = 'LocaleRead'] = "LocaleRead";
        ScopesEnum[ScopesEnum["LocaleWrite"] = 'LocaleWrite'] = "LocaleWrite";
        ScopesEnum[ScopesEnum["KeyRead"] = 'KeyRead'] = "KeyRead";
        ScopesEnum[ScopesEnum["KeyWrite"] = 'KeyWrite'] = "KeyWrite";
        ScopesEnum[ScopesEnum["MessageRead"] = 'MessageRead'] = "MessageRead";
        ScopesEnum[ScopesEnum["MessageWrite"] = 'MessageWrite'] = "MessageWrite";
        ScopesEnum[ScopesEnum["NotificationRead"] = 'NotificationRead'] = "NotificationRead";
        ScopesEnum[ScopesEnum["NotificationWrite"] = 'NotificationWrite'] = "NotificationWrite";
    })(ScopesEnum = PermissionErrorInfo.ScopesEnum || (PermissionErrorInfo.ScopesEnum = {}));
})(PermissionErrorInfo = exports.PermissionErrorInfo || (exports.PermissionErrorInfo = {}));
exports.PermissionErrorInfo = PermissionErrorInfo;
var Project = /** @class */ (function () {
    function Project() {
    }
    Project.getAttributeTypeMap = function () {
        return Project.attributeTypeMap;
    };
    Project.discriminator = undefined;
    Project.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "whenUpdated",
            "baseName": "whenUpdated",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "ownerId",
            "baseName": "ownerId",
            "type": "string"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "ownerUsername",
            "baseName": "ownerUsername",
            "type": "string"
        },
        {
            "name": "keys",
            "baseName": "keys",
            "type": "Array<Key>"
        },
        {
            "name": "locales",
            "baseName": "locales",
            "type": "Array<Locale>"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<Message>"
        },
        {
            "name": "members",
            "baseName": "members",
            "type": "Array<ProjectUser>"
        }
    ];
    return Project;
}());
exports.Project = Project;
var ProjectUser = /** @class */ (function () {
    function ProjectUser() {
    }
    ProjectUser.getAttributeTypeMap = function () {
        return ProjectUser.attributeTypeMap;
    };
    ProjectUser.discriminator = undefined;
    ProjectUser.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "whenUpdated",
            "baseName": "whenUpdated",
            "type": "Date"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "ProjectUser.RoleEnum"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "projectOwnerUsername",
            "baseName": "projectOwnerUsername",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "userUsername",
            "baseName": "userUsername",
            "type": "string"
        },
        {
            "name": "userEmail",
            "baseName": "userEmail",
            "type": "string"
        }
    ];
    return ProjectUser;
}());
exports.ProjectUser = ProjectUser;
(function (ProjectUser) {
    var RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["Owner"] = 'Owner'] = "Owner";
        RoleEnum[RoleEnum["Manager"] = 'Manager'] = "Manager";
        RoleEnum[RoleEnum["Developer"] = 'Developer'] = "Developer";
        RoleEnum[RoleEnum["Translator"] = 'Translator'] = "Translator";
    })(RoleEnum = ProjectUser.RoleEnum || (ProjectUser.RoleEnum = {}));
})(ProjectUser = exports.ProjectUser || (exports.ProjectUser = {}));
exports.ProjectUser = ProjectUser;
var ProjectsPaged = /** @class */ (function () {
    function ProjectsPaged() {
    }
    ProjectsPaged.getAttributeTypeMap = function () {
        return ProjectsPaged.attributeTypeMap;
    };
    ProjectsPaged.discriminator = undefined;
    ProjectsPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<Project>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return ProjectsPaged;
}());
exports.ProjectsPaged = ProjectsPaged;
var SearchResponse = /** @class */ (function () {
    function SearchResponse() {
    }
    SearchResponse.getAttributeTypeMap = function () {
        return SearchResponse.attributeTypeMap;
    };
    SearchResponse.discriminator = undefined;
    SearchResponse.attributeTypeMap = [
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "Array<Suggestion>"
        }
    ];
    return SearchResponse;
}());
exports.SearchResponse = SearchResponse;
var Suggestion = /** @class */ (function () {
    function Suggestion() {
    }
    Suggestion.getAttributeTypeMap = function () {
        return Suggestion.attributeTypeMap;
    };
    Suggestion.discriminator = undefined;
    Suggestion.attributeTypeMap = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Data"
        }
    ];
    return Suggestion;
}());
exports.Suggestion = Suggestion;
var User = /** @class */ (function () {
    function User() {
    }
    User.getAttributeTypeMap = function () {
        return User.attributeTypeMap;
    };
    User.discriminator = undefined;
    User.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "whenCreated",
            "baseName": "whenCreated",
            "type": "Date"
        },
        {
            "name": "whenUpdated",
            "baseName": "whenUpdated",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "User.RoleEnum"
        },
        {
            "name": "memberships",
            "baseName": "memberships",
            "type": "Array<ProjectUser>"
        }
    ];
    return User;
}());
exports.User = User;
(function (User) {
    var RoleEnum;
    (function (RoleEnum) {
        RoleEnum[RoleEnum["Admin"] = 'Admin'] = "Admin";
        RoleEnum[RoleEnum["User"] = 'User'] = "User";
    })(RoleEnum = User.RoleEnum || (User.RoleEnum = {}));
})(User = exports.User || (exports.User = {}));
exports.User = User;
var UsersPaged = /** @class */ (function () {
    function UsersPaged() {
    }
    UsersPaged.getAttributeTypeMap = function () {
        return UsersPaged.attributeTypeMap;
    };
    UsersPaged.discriminator = undefined;
    UsersPaged.attributeTypeMap = [
        {
            "name": "list",
            "baseName": "list",
            "type": "Array<User>"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "hasPrev",
            "baseName": "hasPrev",
            "type": "boolean"
        },
        {
            "name": "hasNext",
            "baseName": "hasNext",
            "type": "boolean"
        }
    ];
    return UsersPaged;
}());
exports.UsersPaged = UsersPaged;
var enumsMap = {
    "Activity.TypeEnum": Activity.TypeEnum,
    "PermissionErrorInfo.ScopesEnum": PermissionErrorInfo.ScopesEnum,
    "ProjectUser.RoleEnum": ProjectUser.RoleEnum,
    "User.RoleEnum": User.RoleEnum
};
var typeMap = {
    "ActivitiesPaged": ActivitiesPaged,
    "Activity": Activity,
    "Aggregate": Aggregate,
    "AggregatedNotification": AggregatedNotification,
    "AggregatesPaged": AggregatesPaged,
    "CompletionStageResult": CompletionStageResult,
    "ConstraintViolation": ConstraintViolation,
    "ConstraintViolationError": ConstraintViolationError,
    "ConstraintViolationErrorInfo": ConstraintViolationErrorInfo,
    "Data": Data,
    "FutureInteger": FutureInteger,
    "GenericError": GenericError,
    "GenericErrorInfo": GenericErrorInfo,
    "Key": Key,
    "KeysPaged": KeysPaged,
    "Locale": Locale,
    "LocalesPaged": LocalesPaged,
    "Message": Message,
    "MessagesPaged": MessagesPaged,
    "NotFoundError": NotFoundError,
    "NotFoundErrorInfo": NotFoundErrorInfo,
    "NotificationsPaged": NotificationsPaged,
    "PermissionError": PermissionError,
    "PermissionErrorInfo": PermissionErrorInfo,
    "Project": Project,
    "ProjectUser": ProjectUser,
    "ProjectsPaged": ProjectsPaged,
    "SearchResponse": SearchResponse,
    "Suggestion": Suggestion,
    "User": User,
    "UsersPaged": UsersPaged
};
var HttpBasicAuth = /** @class */ (function () {
    function HttpBasicAuth() {
        this.username = '';
        this.password = '';
    }
    HttpBasicAuth.prototype.applyToRequest = function (requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    };
    return HttpBasicAuth;
}());
exports.HttpBasicAuth = HttpBasicAuth;
var ApiKeyAuth = /** @class */ (function () {
    function ApiKeyAuth(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    ApiKeyAuth.prototype.applyToRequest = function (requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    };
    return ApiKeyAuth;
}());
exports.ApiKeyAuth = ApiKeyAuth;
var OAuth = /** @class */ (function () {
    function OAuth() {
        this.accessToken = '';
    }
    OAuth.prototype.applyToRequest = function (requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    };
    return OAuth;
}());
exports.OAuth = OAuth;
var VoidAuth = /** @class */ (function () {
    function VoidAuth() {
        this.username = '';
        this.password = '';
    }
    VoidAuth.prototype.applyToRequest = function (_) {
        // Do nothing
    };
    return VoidAuth;
}());
exports.VoidAuth = VoidAuth;
var ActivitiesApiApiKeys;
(function (ActivitiesApiApiKeys) {
})(ActivitiesApiApiKeys = exports.ActivitiesApiApiKeys || (exports.ActivitiesApiApiKeys = {}));
var ActivitiesApi = /** @class */ (function () {
    function ActivitiesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ActivitiesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivitiesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    ActivitiesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    ActivitiesApi.prototype.setApiKey = function (key, value) {
        this.authentications[ActivitiesApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Find aggregated activites
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    ActivitiesApi.prototype.activity = function (accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/activities/aggregated';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling activity.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AggregatesPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Find activites
     * @param accessToken The access token
     * @param search Part of the contents of the activity
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param {*} [options] Override http request options.
     */
    ActivitiesApi.prototype.find = function (accessToken, search, offset, limit, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/activities';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActivitiesPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return ActivitiesApi;
}());
exports.ActivitiesApi = ActivitiesApi;
var KeysApiApiKeys;
(function (KeysApiApiKeys) {
})(KeysApiApiKeys = exports.KeysApiApiKeys || (exports.KeysApiApiKeys = {}));
var KeysApi = /** @class */ (function () {
    function KeysApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(KeysApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeysApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    KeysApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    KeysApi.prototype.setApiKey = function (key, value) {
        this.authentications[KeysApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Delete key
     * @param keyId The key ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    KeysApi.prototype._delete = function (keyId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/key/{keyId}'
            .replace('{' + 'keyId' + '}', encodeURIComponent(String(keyId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'keyId' is not null or undefined
        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling _delete.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling _delete.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Key");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get key by ID
     * @param username The user username
     * @param projectName The project name
     * @param keyName The name of the key
     * @param accessToken The access token
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    KeysApi.prototype.byOwnerAndProjectNameAndName = function (username, projectName, keyName, accessToken, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/{username}/{projectName}/keys/{keyName}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'projectName' + '}', encodeURIComponent(String(projectName)))
            .replace('{' + 'keyName' + '}', encodeURIComponent(String(keyName)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        // verify required parameter 'projectName' is not null or undefined
        if (projectName === null || projectName === undefined) {
            throw new Error('Required parameter projectName was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        // verify required parameter 'keyName' is not null or undefined
        if (keyName === null || keyName === undefined) {
            throw new Error('Required parameter keyName was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Key");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Create key
     * @param body The key to create
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    KeysApi.prototype.create = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/key';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling create.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Key")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Key");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Find keys
     * @param projectId The project ID
     * @param accessToken The access token
     * @param search Part of the name of the key
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    KeysApi.prototype.find = function (projectId, accessToken, search, offset, limit, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/keys/{projectId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling find.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "KeysPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get key by ID
     * @param keyId The key ID
     * @param accessToken The access token
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    KeysApi.prototype.get = function (keyId, accessToken, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/key/{keyId}'
            .replace('{' + 'keyId' + '}', encodeURIComponent(String(keyId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'keyId' is not null or undefined
        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling get.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling get.');
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Key");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Update key
     * @param body The key to update
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    KeysApi.prototype.update = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/key';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling update.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Key")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Key");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return KeysApi;
}());
exports.KeysApi = KeysApi;
var LocalesApiApiKeys;
(function (LocalesApiApiKeys) {
})(LocalesApiApiKeys = exports.LocalesApiApiKeys || (exports.LocalesApiApiKeys = {}));
var LocalesApi = /** @class */ (function () {
    function LocalesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(LocalesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LocalesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    LocalesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    LocalesApi.prototype.setApiKey = function (key, value) {
        this.authentications[LocalesApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Delete locale
     * @param localeId The locale ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype._delete = function (localeId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locale/{localeId}'
            .replace('{' + 'localeId' + '}', encodeURIComponent(String(localeId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'localeId' is not null or undefined
        if (localeId === null || localeId === undefined) {
            throw new Error('Required parameter localeId was null or undefined when calling _delete.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling _delete.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get locale by ID
     * @param username The user username
     * @param projectName The project name
     * @param localeName The name of the locale
     * @param accessToken The access token
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.byOwnerAndProjectNameAndName = function (username, projectName, localeName, accessToken, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/{username}/{projectName}/locales/{localeName}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'projectName' + '}', encodeURIComponent(String(projectName)))
            .replace('{' + 'localeName' + '}', encodeURIComponent(String(localeName)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        // verify required parameter 'projectName' is not null or undefined
        if (projectName === null || projectName === undefined) {
            throw new Error('Required parameter projectName was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        // verify required parameter 'localeName' is not null or undefined
        if (localeName === null || localeName === undefined) {
            throw new Error('Required parameter localeName was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling byOwnerAndProjectNameAndName.');
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Locale");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Create locale
     * @param body The locale to create
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.create = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locale';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling create.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Locale")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Locale");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Download messages of locale
     * @param localeId
     * @param fileType
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.download = function (localeId, fileType, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locale/{localeId}/export/{fileType}'
            .replace('{' + 'localeId' + '}', encodeURIComponent(String(localeId)))
            .replace('{' + 'fileType' + '}', encodeURIComponent(String(fileType)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'localeId' is not null or undefined
        if (localeId === null || localeId === undefined) {
            throw new Error('Required parameter localeId was null or undefined when calling download.');
        }
        // verify required parameter 'fileType' is not null or undefined
        if (fileType === null || fileType === undefined) {
            throw new Error('Required parameter fileType was null or undefined when calling download.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling download.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Download messages of locale
     * @param username
     * @param projectName
     * @param localeName
     * @param fileType
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.downloadBy = function (username, projectName, localeName, fileType, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/{username}/{projectName}/locales/{localeName}/export/{fileType}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'projectName' + '}', encodeURIComponent(String(projectName)))
            .replace('{' + 'localeName' + '}', encodeURIComponent(String(localeName)))
            .replace('{' + 'fileType' + '}', encodeURIComponent(String(fileType)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling downloadBy.');
        }
        // verify required parameter 'projectName' is not null or undefined
        if (projectName === null || projectName === undefined) {
            throw new Error('Required parameter projectName was null or undefined when calling downloadBy.');
        }
        // verify required parameter 'localeName' is not null or undefined
        if (localeName === null || localeName === undefined) {
            throw new Error('Required parameter localeName was null or undefined when calling downloadBy.');
        }
        // verify required parameter 'fileType' is not null or undefined
        if (fileType === null || fileType === undefined) {
            throw new Error('Required parameter fileType was null or undefined when calling downloadBy.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling downloadBy.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Find locales
     * @param projectId The project ID
     * @param accessToken The access token
     * @param localeName The name of the locale
     * @param search Part of the name of the locale
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param fetch The fields to fetch additionally, separated by commas
     * @param messagesKeyName The name of the key of fetched messages - use in combination with fetch: messages
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.find = function (projectId, accessToken, localeName, search, offset, limit, fetch, messagesKeyName, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locales/{projectId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling find.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (localeName !== undefined) {
            localVarQueryParameters['localeName'] = ObjectSerializer.serialize(localeName, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (messagesKeyName !== undefined) {
            localVarQueryParameters['messages.keyName'] = ObjectSerializer.serialize(messagesKeyName, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "LocalesPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get locale by ID
     * @param localeId The locale ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.get = function (localeId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locale/{localeId}'
            .replace('{' + 'localeId' + '}', encodeURIComponent(String(localeId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'localeId' is not null or undefined
        if (localeId === null || localeId === undefined) {
            throw new Error('Required parameter localeId was null or undefined when calling get.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling get.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Locale");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Update locale
     * @param body The locale to update
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.update = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locale';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling update.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Locale")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Locale");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Upload messages to locale
     * @param localeId The locale ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    LocalesApi.prototype.upload = function (localeId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/locale/{localeId}/import'
            .replace('{' + 'localeId' + '}', encodeURIComponent(String(localeId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'localeId' is not null or undefined
        if (localeId === null || localeId === undefined) {
            throw new Error('Required parameter localeId was null or undefined when calling upload.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling upload.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Locale");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return LocalesApi;
}());
exports.LocalesApi = LocalesApi;
var MessagesApiApiKeys;
(function (MessagesApiApiKeys) {
})(MessagesApiApiKeys = exports.MessagesApiApiKeys || (exports.MessagesApiApiKeys = {}));
var MessagesApi = /** @class */ (function () {
    function MessagesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(MessagesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MessagesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    MessagesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    MessagesApi.prototype.setApiKey = function (key, value) {
        this.authentications[MessagesApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Delete message
     * @param messageId The message ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype._delete = function (messageId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/message/{messageId}'
            .replace('{' + 'messageId' + '}', encodeURIComponent(String(messageId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling _delete.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling _delete.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Message");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Create message
     * @param body The message to create
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.create = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/message';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling create.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Message")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Message");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Find messages
     * @param projectId The project ID
     * @param accessToken The access token
     * @param localeId The locale ID
     * @param keyName The name of the key
     * @param search Part of the value of the message
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.find = function (projectId, accessToken, localeId, keyName, search, offset, limit, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/messages/{projectId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling find.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (localeId !== undefined) {
            localVarQueryParameters['localeId'] = ObjectSerializer.serialize(localeId, "string");
        }
        if (keyName !== undefined) {
            localVarQueryParameters['keyName'] = ObjectSerializer.serialize(keyName, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MessagesPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get message by ID
     * @param messageId The message ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.get = function (messageId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/message/{messageId}'
            .replace('{' + 'messageId' + '}', encodeURIComponent(String(messageId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling get.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling get.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Message");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Update message
     * @param body The message to update
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.update = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/message';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling update.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Message")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Message");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return MessagesApi;
}());
exports.MessagesApi = MessagesApi;
var NotificationsApiApiKeys;
(function (NotificationsApiApiKeys) {
})(NotificationsApiApiKeys = exports.NotificationsApiApiKeys || (exports.NotificationsApiApiKeys = {}));
var NotificationsApi = /** @class */ (function () {
    function NotificationsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(NotificationsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    NotificationsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    NotificationsApi.prototype.setApiKey = function (key, value) {
        this.authentications[NotificationsApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Find notifications
     * @param accessToken The access token
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param {*} [options] Override http request options.
     */
    NotificationsApi.prototype.find = function (accessToken, offset, limit, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/notifications';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "NotificationsPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return NotificationsApi;
}());
exports.NotificationsApi = NotificationsApi;
var ProjectsApiApiKeys;
(function (ProjectsApiApiKeys) {
})(ProjectsApiApiKeys = exports.ProjectsApiApiKeys || (exports.ProjectsApiApiKeys = {}));
var ProjectsApi = /** @class */ (function () {
    function ProjectsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ProjectsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    ProjectsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    ProjectsApi.prototype.setApiKey = function (key, value) {
        this.authentications[ProjectsApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Delete project
     * @param projectId The project ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype._delete = function (projectId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/project/{projectId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling _delete.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling _delete.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get project by ID
     * @param projectId The project ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.activity = function (projectId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/project/{projectId}/activity'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling activity.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling activity.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AggregatesPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get project by ID
     * @param username The user username
     * @param projectName The project name
     * @param accessToken The access token
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.byOwnerAndName = function (username, projectName, accessToken, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/{username}/{projectName}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'projectName' + '}', encodeURIComponent(String(projectName)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling byOwnerAndName.');
        }
        // verify required parameter 'projectName' is not null or undefined
        if (projectName === null || projectName === undefined) {
            throw new Error('Required parameter projectName was null or undefined when calling byOwnerAndName.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling byOwnerAndName.');
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Create project
     * @param body The project to create
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.create = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/project';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling create.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Project")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Find projects
     * @param accessToken The access token
     * @param search The search term
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.find = function (accessToken, search, offset, limit, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/projects';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ProjectsPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get project by ID
     * @param projectId The project ID
     * @param accessToken The access token
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.get = function (projectId, accessToken, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/project/{projectId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling get.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling get.');
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Search the contents of the project
     * @param id
     * @param accessToken The access token
     * @param search The search term
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.search = function (id, accessToken, search, offset, limit, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/project/{id}/search'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling search.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling search.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SearchResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Update project
     * @param body The project to update
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    ProjectsApi.prototype.update = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/project';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling update.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Project")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return ProjectsApi;
}());
exports.ProjectsApi = ProjectsApi;
var UsersApiApiKeys;
(function (UsersApiApiKeys) {
})(UsersApiApiKeys = exports.UsersApiApiKeys || (exports.UsersApiApiKeys = {}));
var UsersApi = /** @class */ (function () {
    function UsersApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth()
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(UsersApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UsersApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    UsersApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    UsersApi.prototype.setApiKey = function (key, value) {
        this.authentications[UsersApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary Delete user
     * @param userId The project ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype._delete = function (userId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling _delete.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling _delete.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get user by ID
     * @param userId The user ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.activity = function (userId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/user/{userId}/activity'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling activity.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling activity.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AggregatesPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get user by ID
     * @param username The user username
     * @param accessToken The access token
     * @param fetch The fields to fetch additionally, separated by commas
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.byName = function (username, accessToken, fetch, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling byName.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling byName.');
        }
        if (fetch !== undefined) {
            localVarQueryParameters['fetch'] = ObjectSerializer.serialize(fetch, "string");
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Create user
     * @param body The user to create
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.create = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/user';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling create.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "User")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Find users
     * @param accessToken The access token
     * @param search Part of the name of the user
     * @param offset The first row of the paged result list
     * @param limit The page size of the paged result list
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.find = function (accessToken, search, offset, limit, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/users';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling find.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "UsersPaged");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get user by ID
     * @param userId The user ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.get = function (userId, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling get.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling get.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Get user by ID
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.me = function (accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/me';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling me.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * @summary Update user
     * @param body The user to update
     * @param accessToken The access token
     * @param {*} [options] Override http request options.
     */
    UsersApi.prototype.update = function (body, accessToken, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/user';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }
        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling update.');
        }
        if (accessToken !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "User")
        };
        this.authentications["default"].applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return UsersApi;
}());
exports.UsersApi = UsersApi;
